# Resumo

De início, fomos apresentados ao **Git**, sendo este um sistema de controle de versionamento distribuido (destaca-se que não se trata do único sistema de controle de versionamento disponível, mas sim do mais difundido nas empresas atuais observados todos os seus benefícios, como a segurança e o controle de versões com o **SHA**). Posto isso, passamos por uma breve apresentação do **GitHub**, que se trata de  uma plataforma de hospedagem de códigos e arquivos com controle de versionamento utilizando **GIT**. Neste ponto, podemos observar com determinada clareza a distição entre **GIT** e **GitHub**, destaco que neste primeiro momento o **GitHub** apresentou uma plataforma mais voltada para o GUI com uma interação visual, ao passo que a interação com o Git puro se deu através do Git Bash por intermédio de comandos manuais. 

Acerca dos comandos manuais, insta salientar que o professor aclarou tudo desde os comandos básicos de um terminal até o mais avançado para enviar (enpurrar) arquivos de nossa máquina local para o servidor **GitHub**. Deste modo, foram aclaradas, inclusive, formas de ressolução de conflitos de versões. Sendo necessário puxar (pull) a versão mais atual do servidor comparar com a versão constante em sua máquina, resolver conflitos apontados em arquivos/linhas especifícas para posteriormente efetuar o push. 

Logicamente, para que tudo isso fosse compreendido de forma consisa, fomos apresentados aos sistemas de blob's, tree's e commit's, toda sua interligação e relação com a geração do **SHA-1** que seria a criptografica de todos os elementos constantes em quais quer dos objetos objetos supracitados, formando uma sequência fixa com 40 algoritmos, capaz de ser totalmente alterada com a mudança de uma simples vírgula (ou qualquer caractere) do objeto "original"

Outro ponto que creio que seja relevante apontar, seria o ciclo dos aruivos dentro do **GIT**. Inicialmente temos os termos "Tracked" e "Untracked", sendo: Tracked os arquivos que o git possui ciência da sua existência e Untracked os arquivos ainda desconhecidos pelo Git. Dentro de Tracked, temos Unmodifield: arquivo não modificado; Modifield: arquivo modificado; Staged: arquivo pronto para ser comidatado (atrás das cortinas para entrar no teatro). Neste sentido, o comando git add pode modificar um arquivo de status Untracked direto para Staged. O git compara o **SHA-1** dos arquivos para saber se houve qualquer alteração das versões, sendo possível identificar a alteração de um arquivo Unmodifiel para Modifield. O "git add" também passa o arquivo Modfield para Staged. Por fim, estando os arquivos em estado Staged, ele pode receber um Commit, retornado os arquivos para Unmodifield, registrando um retrato do arquivo mais atualizado. 

Destaca-se que a utilização da extenção .md, é bem útil nesses projetos sendo uma versão humanizada próxima ao HTML, o Markdown se mostra uma estrutura de escrita interessante para utilizarmos sobretudo por ser familiarizada com o **GitHub**. deixar um arquivo .md fora de um pasta faz com que ele se torne a "capa" do seu projeto quando ocorrer o push para o **GitHub**.

Quanto as terminologias pastas, diretórios e repositórios, podemos anotar que pasta e repositório são sinônimos, servindo para armazenar arquivos. O repositório, por sua vez, também é um local onde se armazena arquivos, entretanto possui um plus pois serve para o controle de versões no Git e outros. Assim sendo, concluímos que um repositório é um local onde os dados são armazenados e monitorados, ao passo que um diretório/pasta apenas os armazena, salvo quando um diretório se torna um repositório, com o uso do "gir init" visto no curso.


